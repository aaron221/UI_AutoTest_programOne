debug模式调试思路：
1.在调试的时候，假如发现代码有误，导致无法正确执行，先是检查一下所有代码被正确监视没有，没有的话就先加上监视器后，再去分析
2.根据经验大概判断下有可能是什么原因导致的问题，然后根据在相应的地方打断点进行调试以确认是否是该问题引起的错误
3.然后再根据实际抛出的异常进行分析，不清楚的异常可以先百度查询一下，然后再根据实际所写代码进行结合分析，然后再针对性的去进行调试解决


需要注意的地方：
1.在对某类动作进行封装时，首先要梳理一遍，所有的动作流程，有什么地方需要注意的，比如假如封装的方法中存在driver随着代码的不断执行而不断改变，这时候就需要考虑在定位元素的时候，此driver是否是正确的driver，然后传递的元素参数最好要以By的类型传入进来，以保证定位元素所使用到的driver是正确的。

2.在进行iframe的转换的时候，要注意转换正确了，确保上下元素所在框架是否正确

3.在有拖动条的情况下，注意对拖动条的操作以正确定位到页面上的元素，为了保证代码的健壮性，可以考虑在对拖动条进行操作后，暂停一秒后再去定位元素，以尽量做到与实际操作一致

4.写自动化脚本的时候，写之前最好先梳理一遍用例，以实际手动操作为标准，然后根据实际标准去进行编码，注意简洁性，尽量让人一看代码就觉得就是这么回事，这么简单

5.有时候对某个代码问题想了稍微有点久没想到解决方案的时候，这时候千万别钻牛角尖一定要先把这个解决了再搞后面的，最后搞的自己脑袋昏昏沉沉的，这时候应该跳过这个问题，然后去做其他事情，有时候当你放松的时候，走着走着就会突然想到解决方案了的，这点我经过了多次验证

6.写代码的时候，养成合理的注释以及对代码进行监视习惯，有助于代码复查以及问题快速解决

7.关于元素的显示规则：当driver不进行刷新的时候，进入某个页面后，假如下面的元素显示出来了，上面的元素肯定也能定位到，所以可以通过适当方式去确定某些个元素是否都显示，比如通过拖动滚动条到某一最下面元素显示，那么上面的元素肯定也都显示出来了

8.有时候在进行界面转换的时候，可以在转换操作前后加个一秒休眠时间，这样就不会由于driver的不同而找不到相关元素了

9.在编写自动化脚本的时候，先梳理一遍实际操作，然后找出共同点以及不同点，利用循环以及分支模式对代码进行合理优化，尽量简化。

10.代码debug的时候，注意代码执行路径，确保所有需要执行的代码都执行了

11.由一个元素通过findelement方式去找另外一个元素时候，另外一个元素的路径是相当于这个元素来定，比如element.findelement(By.xpath("following-sibling::div")) 此处表示找这个元素的同级
或者element.findelement（By.xpath("div/span")）此处是找这个元素下的div下的span标签元素
使用parent以及其他xpath轴定位时候，都需要在关键词后面注明标签类型 比如By.xpaht("//input[@id='123']/parent::div") 表明定位到input标签元素的父级元素div

12.编写自动化用例时候，要关注每行代码执行后，会发生哪些变化，需不需要做些什么操作防止代码执行完毕后达不到要实现的效果。

13.使用list装元素的时候，尽量装By类型，不去装元素，因为这时候driver有可能不同的，使用list装元素，基本上用来获取动态变化的标签总数量，不能根据这个去进行定位，除非转换成By模式，找到变化规律即可转换成by类型去定位元素

14.元素定位问题总结：
a.元素存在，但是被遮挡了或者隐藏了，这时候就是element not visited、clickable。就算你上面添加了那句也没用，因为元素存在啊。这时候大可不必写死让线程水几秒。而是可以让线程每次睡0.5s，直到几秒s后。
b.首先是元素不存在，也就是element not existed,这时候先检查iframe框架是否正确，然后是否设置了元素等待
c.接下来就是我要说的比较坑的一个，也是上面那个情况的变种。用例操作步骤是点击弹窗的确定按钮，弹窗消失后点击被弹窗挡住焦点的某个按键。情况是：点击弹窗口，页面关弹窗的时候卡了一下，但是这时候没刷新页面，卡完了才刷新页面。
这时候就有个问题了。关弹窗卡的时候，你要点的元素存在，因为是隐藏状态，所以在第2点代码(上面我写的代码)处等待显示；关闭弹窗后，页面刷新了，然后页面元素要重新加载才行，而代码如果恰好走到
element.isDisplay()这行，那么就会报错：element is not attached in page。 解决办法就是写死Thread.currentThread().sleep(3000); 没办法，因为element并没有提供isClicked()方法。按照webdriver的
想法：既然存在并且没有被遮挡和隐藏，那就可以点击，除非本身就不可以点击。

15.修改用例中，注意需要把原始值给输出到日志中去，万一还原过程中发生了错误还可以查看日志进行还原操作。

16.切换iframe方法：driver.switch_to.frame(0)  # 1.用frame的index来定位，第一个是0
# driver.switch_to.frame("frame1")  # 2.用id来定位
# driver.switch_to.frame("myframe")  # 3.用name来定位
# driver.switch_to.frame(driver.find_element_by_tag_name("iframe"))  # 4.用WebElement对象来定位